export const escapedCode = "// <free_field_name>VisionAi</free_field_name>\n// <file_name>VisionAi.jsx</file_name>\nfunction VisionAi({ env, formData, value, onChange }) {\n  const [outPut, setOutPut] = useState(\"\");\n  const [loading, setLoading] = useState(false); // 新增 loading 状态\n  const mapConfig = {{fieldMappings}};\n  const structuredOutput = {{structuredOutput}};\n  const triggerButtonConfig = {{triggerButtonConfig}};\n  const handleClick = async () => {\n    try {\n      const imageUrl = getImageUrlOfControl(\n        formData[\"{{source_image_id}}\"].value\n      );\n      setOutPut(\"\");\n      setLoading(true); // 设置为 loading 状态\n      // JSONL 解析状态\n      let inJsonlBlock = false;\n      let jsonlBuffer = \"\"; // 仅在 jsonl 代码块内累计\n      let pendingLine = \"\"; // 处理跨 chunk 的行拼接\n      const res = await fetch(\"{{baseURL}}\", {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n          authorization: \"Bearer {{apiKey}}\",\n        },\n        body: JSON.stringify({\n          model: \"{{modelName}}\",\n          stream: true,\n          messages: [\n            {{prompt}},\n            {\n              role: \"user\",\n              content: [\n                {\n                  type: \"image_url\",\n                  image_url: {\n                    url: imageUrl,\n                  },\n                },\n              ],\n            },\n          ],\n        }),\n      });\n      if (!res.ok) {\n        try {\n          const errText = await res.text();\n          let msg = errText;\n          try {\n            const j = JSON.parse(errText);\n            msg = j.error?.message || j.message || errText;\n          } catch (_) {}\n          throw new Error(`请求失败(${res.status}): ${msg}`);\n        } catch (e) {\n          throw new Error(`请求失败(${res.status})`);\n        }\n      }\n      let hasErrored = false;\n      await OpenAISSEParser.fromResponse(res, (event) => {\n        if (event.type === \"message\") {\n          if (hasErrored) return;\n          // 识别服务端以 JSON 形式返回的错误并提前终止\n          try {\n            if (event.data && typeof event.data === \"object\" && event.data.error) {\n              hasErrored = true;\n              console.error(\"Error:\", event.data.error);\n              setLoading(false);\n              return;\n            }\n            if (typeof event.data === \"string\" && event.data.trim().startsWith(\"{\\\"error\\\"\")) {\n              const ej = JSON.parse(event.data);\n              hasErrored = true;\n              console.error(\"Error:\", ej.error || ej);\n              setLoading(false);\n              return;\n            }\n          } catch (_) {}\n          const delta = event.data.choices?.[0]?.delta?.content;\n          if (delta) {\n            setOutPut((prev) => {\n              let newOutPut = prev + delta;\n              onChange(newOutPut, \"{{result_id}}\");\n              // 检测与解析 jsonl 代码块\n              // 进入代码块：```jsonl\n              if (!inJsonlBlock) {\n                const startIdx = newOutPut.lastIndexOf(\"```jsonl\");\n                if (startIdx !== -1) {\n                  inJsonlBlock = true;\n                  // 截取从起始标记后的新增增量部分参与解析\n                  const afterStart = newOutPut.slice(startIdx + 7); // 长度不关键，此处只表示进入块后\n                  // 只处理当前 delta 内的新增以减少开销\n                }\n              }\n\n              if (inJsonlBlock) {\n                // 将本次增量加入缓冲\n                jsonlBuffer += delta;\n                // 如果出现结束标记，先截断到结束标记之前\n                const endIdx = jsonlBuffer.indexOf(\"```\");\n                let parseTarget = jsonlBuffer;\n                if (endIdx !== -1) {\n                  parseTarget = jsonlBuffer.slice(0, endIdx);\n                }\n                // 逐行解析（不跨对象换行的前提下）\n                const parts = (pendingLine + parseTarget).split(\"\\n\");\n                pendingLine = parts.pop() || \"\"; // 保留最后一行（可能不完整）\n                for (const lineRaw of parts) {\n                  const line = lineRaw.trim();\n                  if (!line) continue;\n                  try {\n                    const obj = JSON.parse(line);\n                    if (obj && typeof obj === \"object\" && obj.key != null) {\n                      onChange(obj.value, String(obj.key));\n                    }\n                  } catch (e) {\n                    // 单行解析失败时忽略该行，继续后续行\n                  }\n                }\n                // 如果检测到结束标记，则退出块并清理缓冲，尝试处理最后残留的一行\n                if (endIdx !== -1) {\n                  inJsonlBlock = false;\n                  jsonlBuffer = \"\";\n                  if (pendingLine.trim()) {\n                    try {\n                      const tailObj = JSON.parse(pendingLine.trim());\n                      if (tailObj && typeof tailObj === \"object\" && tailObj.key != null) {\n                        onChange(tailObj.value, String(tailObj.key));\n                      }\n                    } catch (e) {}\n                  }\n                  pendingLine = \"\";\n                }\n              }\n              return newOutPut;\n            });\n          }\n        } else if (event.type === \"done\") {\n          // 结构化输出在 jsonl 流期间已逐字段更新，这里无需再整块解析\n          console.log(\"\\n[Stream finished]\");\n          setLoading(false); // 请求完成，重置 loading 状态\n         } else if (event.type === \"error\") {\n          console.error(\"Error:\", event.error);\n          setLoading(false); // 请求出错，重置 loading 状态\n        }\n      });\n    } catch (error) {\n      console.error(\"Error:\", error);\n      setLoading(false); // 请求出错，重置 loading 状态\n    }\n  };\n\n  return (\n    <TriggerButton\n      style={triggerButtonConfig.style}\n      textStyle={triggerButtonConfig.textStyle}\n      isLoading={loading}\n      iconName={triggerButtonConfig.iconName}\n      loadingIconName={triggerButtonConfig.loadingIconName}\n      iconPosition={triggerButtonConfig.iconPosition}\n      iconColor={triggerButtonConfig.iconColor}\n      iconSize={triggerButtonConfig.iconSize}\n      text={triggerButtonConfig.text}\n      loadingText={triggerButtonConfig.loadingText}\n      onClick={loading ? null : handleClick} // 如果 loading，禁用点击\n    />\n  );\n}\n\nfunction TriggerButton({\n  style = {},\n  textStyle = {},\n  isLoading = false,\n  iconName = \"ArrowRight\", // lucide-react icon name 比如 ChefHat, Settings\n  loadingIconName = \"loader\", // lucide-react icon name 比如 ChefHat, Settings\n  iconPosition = \"right\", // left, right\n  iconColor = \"white\",\n  iconSize = 18,\n  text = \"开始\",\n  loadingText = \"处理中\",\n  onClick,\n}) {\n  const iconComp = <LucideIcon\n    name={isLoading ? loadingIconName : iconName}\n    className={\"m-[2px]\" + (isLoading ? \" animate-spin\" : \"\")}\n    size={iconSize}\n    color={isLoading ? \"#aaa\" : iconColor}\n  />;\n  return (\n    <div style={style} className=\"flex items-center justify-center\" onClick={onClick}>\n      { iconName && iconPosition === \"left\" && iconComp }\n      <span style={textStyle}>{isLoading ? loadingText : text}</span>\n      { iconName && iconPosition === \"right\" && iconComp }\n    </div>\n  );\n}\n\n/**\n * OpenAISSEParser\n *\n * 用于解析 OpenAI 接口返回的 SSE 流数据\n * 通过 reader.feed() 不断输入数据，类会解析出完整的事件并触发回调\n */\nclass OpenAISSEParser {\n  /**\n   * @param {function({type: string, data?: any}): void} onEvent\n   * 事件回调：type可能为 \"message\" | \"done\" | \"error\"\n   */\n  constructor(onEvent) {\n    this.onEvent = onEvent;\n    this.buffer = \"\"; // 用于拼接不完整的块\n    this.decoder = new TextDecoder(\"utf-8\");\n    this.aborted = false;\n  }\n\n  /**\n   * 向解析器提供新的数据块\n   * @param {Uint8Array} chunk\n   */\n  feed(chunk) {\n    if (this.aborted) return;\n    this.buffer += this.decoder.decode(chunk, { stream: true });\n    this._processBuffer();\n  }\n\n  /**\n   * 内部方法：处理缓冲区中的数据\n   */\n  _processBuffer() {\n    let index;\n    while ((index = this.buffer.indexOf(\"\\n\\n\")) !== -1) {\n      const rawEvent = this.buffer.slice(0, index);\n      this.buffer = this.buffer.slice(index + 2);\n      this._parseEvent(rawEvent.trim());\n    }\n  }\n\n  /**\n   * 解析单个事件块\n   */\n  _parseEvent(rawEvent) {\n    if (!rawEvent.startsWith(\"data:\")) return;\n    const dataStr = rawEvent.replace(/^data:\\s*/, \"\");\n    if (dataStr === \"[DONE]\") {\n      this.onEvent?.({ type: \"done\" });\n      this.abort();\n      return;\n    }\n    try {\n      const data = JSON.parse(dataStr);\n      this.onEvent?.({ type: \"message\", data });\n    } catch (err) {\n      // 可能是部分 JSON 或文本流\n      this.onEvent?.({ type: \"message\", data: dataStr });\n    }\n  }\n\n  /**\n   * 停止解析\n   */\n  abort() {\n    this.aborted = true;\n  }\n\n  /**\n   * 从 fetch response 直接读取\n   */\n  static async fromResponse(response, onEvent) {\n    const parser = new OpenAISSEParser(onEvent);\n    const reader = response.body.getReader();\n    try {\n      while (true) {\n        const { value, done } = await reader.read();\n        if (done) break;\n        parser.feed(value);\n      }\n    } catch (err) {\n      onEvent?.({ type: \"error\", error: err });\n    } finally {\n      parser.abort();\n    }\n  }\n}\n\nfunction getImageUrlOfControl(value) {\n  try {\n    const parsedData = JSON.parse(value);\n    if (parsedData.attachments) {\n      return parsedData.attachments[0].url;\n    }\n    return parsedData[0].viewUrl;\n  } catch (err) {\n    return;\n  }\n}\n\nexport function extractJSON(text) {\n  if (!text || typeof text !== \"string\") {\n    return null;\n  }\n\n  // 策略 1: 提取 ```json ... ``` 代码块\n  const jsonBlockMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n  if (jsonBlockMatch) {\n    try {\n      return JSON.parse(jsonBlockMatch[1].trim());\n    } catch (e) {\n      console.warn(\"JSON 代码块解析失败:\", e);\n    }\n  }\n  return null;\n}";